const https = require("https");
const http = require("http"); // Used to interact with the API on localhost:11434
const fs = require("fs");
const path = require("path");

// Load the key and certificate files generated by mkcert or OpenSSL
const options = {
  key: fs.readFileSync(path.join(__dirname, "localhost-key.pem")),
  cert: fs.readFileSync(path.join(__dirname, "localhost.pem")),
};

// Function to interact with the Ollama API (or any other local API over HTTP)
function askMistral(prompt, callback, res) {
  const preprompt = "Tu es un étudiant en informatique français. Réponds toujours en français de manière concise et efficace, comme si tu parlais à un autre étudiant. Utilise un vocabulaire technique mais accessibleniveau eleve de bac+3. Garde tes réponses courtes et directes. Ne dépasse pas 2-3 phrases maximum. Pour un QCM, ne donne que le numéro et la lettre de la bonne réponse. Pour une question de code, ne donne que le code sans aucun commentaire.\n\nQuestion: ";

  const postData = JSON.stringify({
    model: "gemma3:12b",
    prompt: preprompt + prompt,
    max_tokens: 150,
  });

  const reqOptions = {
    hostname: "localhost",
    port: 11434,
    path: "/api/generate",
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Content-Length": Buffer.byteLength(postData),
      // No 'Ollama-Stream' header means streaming is enabled by default
    },
  };

  const req = http.request(reqOptions, (apiRes) => {
    apiRes.setEncoding("utf8");

    let buffer = "";
    let responseText = "";

    // If we have a response object (streaming mode), set appropriate headers
    if (res) {
      res.writeHead(200, {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*'
      });
    }

    apiRes.on("data", (chunk) => {
      buffer += chunk;

      // Split the buffer by newlines to get complete JSON objects
      let lines = buffer.split("\n");
      buffer = lines.pop(); // Keep the last partial line for the next chunk

      lines.forEach((line) => {
        if (line.trim()) {
          try {
            let json = JSON.parse(line);
            if (json.response) {
              responseText += json.response;
              
              // If we're in streaming mode, send the chunk to the client
              if (res) {
                res.write(`data: ${JSON.stringify({ chunk: json.response })}\n\n`);
              }
            }
          } catch (e) {
            console.error("Error parsing JSON line:", e);
          }
        }
      });
    });

    apiRes.on("end", () => {
      // Process any remaining data in the buffer
      if (buffer.trim()) {
        try {
          let json = JSON.parse(buffer);
          if (json.response) {
            responseText += json.response;
            
            // Send the final chunk if in streaming mode
            if (res) {
              res.write(`data: ${JSON.stringify({ chunk: json.response })}\n\n`);
            }
          }
        } catch (e) {
          console.error("Error parsing JSON buffer at end:", e);
        }
      }
      
      // End the stream if in streaming mode
      if (res) {
        res.write(`data: ${JSON.stringify({ done: true })}\n\n`);
        res.end();
      }
      
      // Return the aggregated response to the callback if provided
      if (callback) {
        callback(null, { text: responseText });
      }
    });
  });

  req.on("error", (err) => {
    if (callback) {
      callback(err, null);
    }
    if (res) {
      res.write(`data: ${JSON.stringify({ error: err.message })}\n\n`);
      res.end();
    }
  });

  req.write(postData);
  req.end();
}

// Create the HTTPS server
https
  .createServer(options, (req, res) => {
    if (req.method === "GET" && req.url === "/") {
      // Serve the HTML form (you can remove this if not needed)
      res.writeHead(200, { "Content-Type": "text/html" });
      res.write(`
            <html>
            <body>
                <h1>Chat with Mistral via HTTPS</h1>
                <form method="POST" action="/ask">
                    <label for="prompt">Ask something:</label><br>
                    <input type="text" id="prompt" name="prompt" required><br><br>
                    <input type="submit" value="Submit">
                </form>
            </body>
            </html>
        `);
      res.end();
    } else if (req.method === "POST" && req.url === "/ask") {
      let body = "";

      req.on("data", (chunk) => {
        body += chunk.toString();
      });

      req.on("end", () => {
        const parsedBody = new URLSearchParams(body);
        const prompt = parsedBody.get("prompt");
        const streaming = parsedBody.get("streaming") === "true";

        if (streaming) {
          // Stream the response directly to the client
          askMistral(prompt, null, res);
        } else {
          // Use the traditional callback approach
          askMistral(prompt, (err, apiResponse) => {
            if (err) {
              res.writeHead(500, {
                "Content-Type": "application/json",
              });
              res.end(
                JSON.stringify({
                  error:
                    "Error interacting with API: " +
                    err.message,
                })
              );
            } else {
              res.writeHead(200, {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*", // Allow cross-origin requests
              });
              res.end(JSON.stringify({ response: apiResponse.text }));
            }
          });
        }
      });
    } else if (req.method === "GET" && req.url === "/health") {
      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ status: "OK" }));
    } else {
      // Handle 404 Not Found
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Not Found" }));
    }
  })
  .listen(3005, () => {
    console.log("Server running at https://localhost:3005/");
  });

